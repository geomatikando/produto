<!DOCTYPE html>
<html lang="pt">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
<title>Produto — 1 Jogador / 2 Jogadores</title>
<style>
  :root{
    --bg:#f7f7f7; --panel:#fafafa; --line:#333; --board:#e6e6e6;
    --panel-h:clamp(150px,26vh,200px); /* painel adaptativo no mobile */
  }
  html,body{height:100%;margin:0;background:var(--bg);
    font-family:system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,Arial,sans-serif;color:#222}
  .wrap{display:grid;grid-template-columns:1fr 280px;height:100%}
  .stage{display:flex;align-items:center;justify-content:center;overflow:hidden;background:var(--bg)}
  #board{width:100%;height:100%;display:block;touch-action:none;background:transparent}
  aside{background:var(--panel);border-left:1px solid #ddd;
    display:flex;flex-direction:column;align-items:center;padding:16px}
  h1{margin:6px 0 10px;font-size:22px;letter-spacing:.4px}

  /* Painel em grelha: label | valor (botões de cor à direita) */
  .info-grid{
    width:100%; display:grid; grid-template-columns:auto 1fr;
    column-gap:10px; row-gap:8px; align-items:center;
    font-size:14px; margin:10px 0 12px;
  }
  .label{font-weight:700}
  .value{display:flex;align-items:center;gap:8px;justify-content:flex-end;flex-wrap:wrap}

  .btn{width:100%;padding:12px 14px;margin:8px 0;border:1px solid #aaa;
    border-radius:12px;background:#eee;cursor:pointer;font-weight:600}
  .btn:hover{filter:brightness(0.97)}
  .chip{
    padding:6px 10px;border-radius:999px;border:1px solid #aaa;background:#eee;
    font-weight:600;cursor:pointer;font-size:13px;line-height:1;white-space:nowrap
  }
  .chip:active{transform:translateY(1px)}
  .pill{padding:3px 8px;border-radius:999px;border:1px solid #bbb;background:#fff;font-size:12px}
  .muted{color:#666}
  footer{margin-top:auto;width:100%;display:flex;justify-content:center}
  .modal{position:fixed;inset:0;background:rgba(0,0,0,.55);
    display:none;align-items:center;justify-content:center;padding:24px}
  .card{background:#fff;border-radius:16px;box-shadow:0 10px 30px rgba(0,0,0,.2);
    padding:20px;min-width:280px;max-width:420px;width:100%}
  .card h2{margin:0 0 12px}
  .center{display:flex;gap:10px;justify-content:center;flex-wrap:wrap}

  /* Mobile: painel em baixo e canvas ocupa a área visível restante */
  @media (max-width:900px){
    .wrap{grid-template-columns:1fr}
    aside{
      position:fixed;left:0;right:0;bottom:0;height:var(--panel-h);
      border-left:none;border-top:1px solid #ddd;
      padding:10px 12px calc(10px + env(safe-area-inset-bottom,0px));
      background-clip:padding-box;
    }
    .stage{
      height:calc(var(--vh, 100svh) - var(--panel-h) - env(safe-area-inset-bottom,0px));
    }
    h1{font-size:20px;margin:4px 0 6px}
    .info-grid{font-size:13px;margin:6px 0 8px}
    .btn{padding:10px 12px;font-size:15px}
  }
</style>
</head>
<body>
<div class="wrap">
  <div class="stage"><canvas id="board"></canvas></div>
  <aside id="side">
    <h1>PRODUTO</h1>

    <div class="info-grid">
      <div class="label">Modo:</div>
      <div class="value"><span id="modeLbl" class="pill">1 Jogador</span></div>

      <div class="label">Vez:</div>
      <div class="value">
        <span id="turnLbl">—</span>
        <button class="chip" id="chipBlack">⚫ Preta</button>
        <button class="chip" id="chipWhite">⚪ Branca</button>
      </div>

      <div class="label">Coloca:</div>
      <div class="value">
        <span id="needLbl">—</span> <span class="muted">peça(s)</span>
      </div>

      <div class="label">Cor selecionada:</div>
      <div class="value"><span id="selLbl" class="pill">Preta</span></div>
    </div>

    <button class="btn" id="btnUndo">Undo</button>
    <button class="btn" id="btnReset">Reiniciar</button>

    <div class="info-grid" id="scoreBox" style="grid-template-columns:auto 1fr"></div>
    <footer><button class="btn" id="btnQuit" title="Fecha o separador">Terminar</button></footer>
  </aside>
</div>

<!-- Modal início -->
<div class="modal" id="startModal">
  <div class="card">
    <h2>Escolhe o modo / lado</h2>
    <div class="center">
      <button class="btn" id="startBlack">1 Jogador — Jogar Pretas</button>
      <button class="btn" id="startWhite">1 Jogador — Jogar Brancas</button>
      <button class="btn" id="startPvP">2 Jogadores</button>
    </div>
  </div>
</div>

<script>
(()=>{
/* ===== Altura real do viewport (iOS/Android) ===== */
function setVH(){ document.documentElement.style.setProperty('--vh', window.innerHeight + 'px'); }
setVH(); window.addEventListener('resize', setVH);

/* ===== Config & util ===== */
const SIZE=5; let HEX_R=26;
const PRETO=1, BRANCO=2, VAZIO=0;
const COLOR_NAME={1:'Pretas',2:'Brancas'};
const PIECE_RGB={1:'#222',2:'#f4f4f4'};
const css=v=>getComputedStyle(document.documentElement).getPropertyValue(v).trim();

/* ===== Tabuleiro axial (pointy-top) ===== */
function axialHexCoords(size){const r=size-1,out=[];for(let q=-r;q<=r;q++){const r1=Math.max(-r,-q-r),r2=Math.min(r,-q+r);for(let s=r1;s<=r2;s++)out.push([q,s])}return out}
const COORDS=axialHexCoords(SIZE), N=COORDS.length;
const INDEX=new Map(COORDS.map((c,i)=>[c.toString(),i]));
const NEIGH_DELTAS=[[1,0],[-1,0],[0,1],[0,-1],[1,-1],[-1,1]];
const NEIGH=Array.from({length:N},(_,i)=>{const[q,r]=COORDS[i],a=[];for(const[dq,dr]of NEIGH_DELTAS){const j=INDEX.get([q+dq,r+dr].toString()); if(j!==undefined) a.push(j)}return a});

function axialToPixel(q,r){ return [HEX_R*(Math.sqrt(3)*(q+r/2)), HEX_R*(1.5*r)] }
function hexPolygon(cx,cy){const pts=[];for(let k=0;k<6;k++){const ang=(Math.PI/180)*(60*k+30);pts.push([cx+HEX_R*Math.cos(ang), cy+HEX_R*Math.sin(ang)])}return pts}
function pointInPoly(x,y,poly){let inside=false; for(let i=0;i<poly.length;i++){const[x1,y1]=poly[i],[x2,y2]=poly[(i+1)%poly.length]; const hit=(y1>y)!==(y2>y) && x < (x2-x1)*(y-y1)/(y2-y1+1e-9)+x1; if(hit) inside=!inside;} return inside;}

/* ===== Canvas + ajuste responsivo ===== */
const canvas=document.getElementById('board'), ctx=canvas.getContext('2d');
let originX=0, originY=0;
function fitCanvasAndRadius(){
  const stage=canvas.parentElement;
  const w=stage.clientWidth, h=stage.clientHeight;
  const dpr=Math.max(1, window.devicePixelRatio||1);
  canvas.width=Math.floor(w*dpr); canvas.height=Math.floor(h*dpr);
  canvas.style.width=w+'px'; canvas.style.height=h+'px';
  ctx.setTransform(dpr,0,0,dpr,0,0);

  const centers1=COORDS.map(([q,r])=>[Math.sqrt(3)*(q+r/2), 1.5*r]);
  const xs=centers1.map(p=>p[0]), ys=centers1.map(p=>p[1]);
  const minx=Math.min(...xs)-1, maxx=Math.max(...xs)+1;
  const miny=Math.min(...ys)-1, maxy=Math.max(...ys)+1;
  const widthU=maxx-minx, heightU=maxy-miny;

  const PAD=12;
  const Rx=(w-2*PAD)/widthU, Ry=(h-2*PAD)/heightU;
  HEX_R=Math.max(6, Math.floor(Math.min(Rx,Ry)));

  const boardW=widthU*HEX_R, boardH=heightU*HEX_R;
  originX=(w-boardW)/2 - minx*HEX_R;
  originY=(h-boardH)/2 - miny*HEX_R;
}
window.addEventListener('resize', ()=>{fitCanvasAndRadius(); draw();});

/* ===== Estado do jogo ===== */
let board=Array(N).fill(VAZIO), turn=PRETO, firstBlackDone=false;
let selectedColor=PRETO, pending=[];

/* Modo de jogo */
let gameMode='ai';        // 'ai' | 'pvp'
let humanColor=null;      // usado só em 'ai'

/* ===== Histórico para UNDO ===== */
let history=[];
function pushHistory(){
  history.push({
    board: board.slice(),
    turn,
    firstBlackDone,
    pending: pending.slice(),
    selectedColor,
    gameMode,
    humanColor
  });
  if(history.length>200) history.shift();
}
function restoreState(s){
  board=s.board.slice(); turn=s.turn; firstBlackDone=s.firstBlackDone;
  pending=s.pending.slice(); selectedColor=s.selectedColor;
  gameMode=s.gameMode; humanColor=s.humanColor;
  draw(); updateHUD();
}

/* ===== HUD ===== */
const modeLbl=document.getElementById('modeLbl');
const turnLbl=document.getElementById('turnLbl');
const needLbl=document.getElementById('needLbl');
const selLbl =document.getElementById('selLbl');
const scoreBox=document.getElementById('scoreBox');

document.getElementById('chipBlack').onclick=()=>{selectedColor=PRETO; selLbl.textContent='Preta';};
document.getElementById('chipWhite').onclick=()=>{selectedColor=BRANCO; selLbl.textContent='Branca';};
document.getElementById('btnUndo').onclick=()=>{
  if(pending.length){ const [i]=pending.pop(); board[i]=VAZIO; draw(); updateHUD(); }
  else if(history.length){ restoreState(history.pop()); }
};
document.getElementById('btnReset').onclick=resetGame;
document.getElementById('btnQuit').onclick=()=>window.close();

/* ===== Pontuação ===== */
function groupSizes(color){const seen=new Set(),sizes=[];for(let i=0;i<N;i++) if(board[i]===color && !seen.has(i)){let c=0;const st=[i];seen.add(i);while(st.length){const u=st.pop();c++;for(const v of NEIGH[u]) if(board[v]===color && !seen.has(v)){seen.add(v);st.push(v)}}sizes.push(c)}sizes.sort((a,b)=>b-a);return sizes}
const prod2=a=>a.length>=2?a[0]*a[1]:0;
function evaluate(){const sb=groupSizes(PRETO), sw=groupSizes(BRANCO); return {prod_black:prod2(sb), prod_white:prod2(sw), black_pieces:board.filter(v=>v===PRETO).length, white_pieces:board.filter(v=>v===BRANCO).length, diffFor(me){return me===PRETO? this.prod_black-this.prod_white : this.prod_white-this.prod_black}}}

/* ===== IA ===== */
const empties=()=>board.map((v,i)=>v===VAZIO?i:-1).filter(i=>i!==-1);
function tryPlace(pl){const b=board.slice(), used=new Set();for(const[i,c] of pl){if(used.has(i)||b[i]!==VAZIO) return null; used.add(i); b[i]=c;} return b;}
function evaluateBoard(b){const save=board; board=b; const sc=evaluate(); board=save; return sc;}
function shuffle(a){for(let i=a.length-1;i>0;i--){const j=(Math.random()*(i+1))|0; [a[i],a[j]]=[a[j],a[i]]}}
function gt(a,b){for(let i=0;i<Math.max(a.length,b.length);i++){const x=a[i]??0,y=b[i]??0;if(x>y)return true;if(x<y)return false}return false}
function candidateCells(){const e=empties(); if(e.length<=14) return e; const frontier=new Set(); for(let i=0;i<N;i++) if(board[i]!==VAZIO) for(const j of NEIGH[i]) if(board[j]===VAZIO) frontier.add(j); if(frontier.size){const arr=[...frontier].sort((a,b)=>a-b); if(arr.length<14){const rest=e.filter(x=>!frontier.has(x)); shuffle(rest); arr.push(...rest.slice(0,14-arr.length));} return arr;} let center=0,bv=1e9; for(let i=0;i<N;i++){const[q,r]=COORDS[i],d=Math.abs(q)+Math.abs(r)+Math.abs(-q-r); if(d<bv){bv=d; center=i}} const pool=new Set([center, ...NEIGH[center]]); const rest=e.filter(x=>!pool.has(x)); shuffle(rest); while(pool.size<14 && rest.length) pool.add(rest.pop()); return [...pool].sort((a,b)=>a-b)}
function aiMove(me){
  const base=evaluate(), opp=(me===PRETO?BRANCO:PRETO), baseOpp=(opp===PRETO?base.prod_black:base.prod_white);
  const e=empties(), moveSize=(me===PRETO && !firstBlackDone)?1:2, cands=candidateCells();
  if(moveSize===1){
    let best=null;
    for(const i of cands) for(const col of [PRETO,BRANCO]){
      const nb=tryPlace([[i,col]]); if(!nb) continue; const sc=evaluateBoard(nb);
      const myPieces=(me===PRETO?sc.black_pieces:sc.white_pieces), oppProd=(opp===PRETO?sc.prod_black:sc.prod_white);
      const key=[sc.diffFor(me),(baseOpp-oppProd),-myPieces];
      if(!best||gt(key,best.key)) best={key,mv:[[i,col]]};
    }
    return best?best.mv:[[e[0],me]];
  }
  let singles=[]; for(const i of cands) for(const col of [PRETO,BRANCO]){const nb=tryPlace([[i,col]]); if(!nb) continue; const sc=evaluateBoard(nb); singles.push({key:[sc.diffFor(me)], pick:[i,col]});}
  singles.sort((a,b)=>gt(b.key,a.key)?1:-1); singles=singles.slice(0,12);
  let pool=singles.map(s=>s.pick);
  while(pool.length<18 && e.length){const i=e[(Math.random()*e.length)|0]; const c=(Math.random()<.5?PRETO:BRANCO); pool.push([i,c]);}
  for(let k=0;k<8 && e.length>1;k++){let i1=e[(Math.random()*e.length)|0],i2=e[(Math.random()*e.length)|0]; if(i1===i2)continue; const c1=(Math.random()<.5?PRETO:BRANCO), c2=(c1===PRETO?BRANCO:PRETO); pool.push([i1,c1],[i2,c2]);}
  let best=null; const tried=new Set();
  for(let a=0;a<pool.length;a++) for(let b=a+1;b<pool.length;b++){
    const [i1,c1]=pool[a],[i2,c2]=pool[b]; if(i1===i2) continue;
    const id=JSON.stringify([[i1,c1],[i2,c2]].sort()); if(tried.has(id)) continue; tried.add(id);
    const nb=tryPlace([[i1,c1],[i2,c2]]); if(!nb) continue; const sc=evaluateBoard(nb);
    const myPieces=(me===PRETO?sc.black_pieces:sc.white_pieces), oppProd=(opp===PRETO?sc.prod_black:sc.prod_white);
    const key=[sc.diffFor(me)+Math.random()*0.01,(baseOpp-oppProd),-myPieces];
    if(!best||gt(key,best.key)) best={key,mv:[[i1,c1],[i2,c2]]};
  }
  return best?best.mv:(e.length>1?[[e[0],me],[e[1],me]]:[[e[0],me]]);
}

/* ===== Início / modo ===== */
document.getElementById('startBlack').onclick=()=>{ gameMode='ai'; humanColor=PRETO; modeLbl.textContent='1 Jogador'; startGame(); };
document.getElementById('startWhite').onclick=()=>{ gameMode='ai'; humanColor=BRANCO; modeLbl.textContent='1 Jogador'; startGame(true); };
document.getElementById('startPvP').onclick=()=>{ gameMode='pvp'; humanColor=null; modeLbl.textContent='2 Jogadores'; startGame(); };

function startGame(aiStarts=false){
  document.getElementById('startModal').style.display='none';
  updateHUD(); draw();
  if(aiStarts) setTimeout(aiStep, 300);
}

/* ===== Interação ===== */
canvas.addEventListener('click', e=>handlePointer(e.clientX,e.clientY));
canvas.addEventListener('touchstart', e=>{const t=e.changedTouches[0]; handlePointer(t.clientX,t.clientY); e.preventDefault();},{passive:false});

function isHumanTurn(){
  return gameMode==='pvp' || (gameMode==='ai' && humanColor===turn);
}

function handlePointer(clientX,clientY){
  if(!isHumanTurn()) return;
  const rect=canvas.getBoundingClientRect(); const x=clientX-rect.left, y=clientY-rect.top;

  for(let i=0;i<N;i++){
    if(board[i]!==VAZIO) continue;
    const [q,r]=COORDS[i];
    const cx=HEX_R*(Math.sqrt(3)*(q+r/2))+originX, cy=HEX_R*(1.5*r)+originY;
    const poly=hexPolygon(cx,cy);
    if(pointInPoly(x,y,poly)){
      if(pending.length===0) pushHistory();  // snapshot para Undo do turno
      board[i]=selectedColor; pending.push([i,selectedColor]); draw(); updateHUD();

      const need=(turn===PRETO && !firstBlackDone)?1:2;
      if(pending.length>=need){
        pending.length=0;
        if(turn===PRETO && !firstBlackDone) firstBlackDone=true;

        turn=(turn===PRETO)?BRANCO:PRETO;
        draw(); updateHUD();

        /* ✅ NOVO: se for 2 Jogadores e encheu o tabuleiro, anuncia vencedor */
        if (gameMode==='pvp' && !board.some(v=>v===VAZIO)) {
          endGame();
          return;
        }

        if(gameMode==='ai') setTimeout(aiStep,220);
      }
      break;
    }
  }
}

/* ===== IA joga ===== */
function aiStep(){
  if(gameMode!=='ai') return;
  if(!board.some(v=>v===VAZIO)) return endGame();
  if(humanColor===turn) return;

  pushHistory(); // snapshot antes da jogada da IA
  const mv=aiMove(turn); for(const [i,c] of mv) board[i]=c;
  if(turn===PRETO && !firstBlackDone) firstBlackDone=true;
  turn=(turn===PRETO)?BRANCO:PRETO;
  draw(); updateHUD();
  if(!board.some(v=>v===VAZIO)) endGame();
}

/* ===== HUD / resultado ===== */
function updateHUD(){
  const need=(turn===PRETO && !firstBlackDone)?1:2;
  turnLbl.textContent=COLOR_NAME[turn];
  needLbl.textContent=need;
  const sc=evaluate();
  scoreBox.innerHTML=
    `<div class="label">Produto Pretas:</div><div class="value" style="justify-content:flex-start">${sc.prod_black}</div>
     <div class="label">Produto Brancas:</div><div class="value" style="justify-content:flex-start">${sc.prod_white}</div>
     <div class="label muted">Peças:</div><div class="value muted" style="justify-content:flex-start">P:${sc.black_pieces}  |  W:${sc.white_pieces}</div>`;
}

function endGame(){
  const sc=evaluate();
  let winner=null;
  if(sc.prod_black!==sc.prod_white) winner=sc.prod_black>sc.prod_white?PRETO:BRANCO;
  else if(sc.black_pieces!==sc.white_pieces) winner=sc.black_pieces<sc.white_pieces?PRETO:BRANCO;

  alert(`Produto Pretas: ${sc.prod_black}\nProduto Brancas: ${sc.prod_white}\nPeças P:${sc.black_pieces}  W:${sc.white_pieces}\n\n${winner?`Vence: ${COLOR_NAME[winner]}`:'Empate absoluto!'}`);

  // 👇 volta ao menu inicial
  resetGame();
}

function resetGame(){
  board.fill(VAZIO); turn=PRETO; firstBlackDone=false; pending.length=0; selectedColor=PRETO; history.length=0;
  modeLbl.textContent = (gameMode==='pvp'?'2 Jogadores':'1 Jogador');
  selLbl.textContent='Preta';
  draw(); updateHUD(); document.getElementById('startModal').style.display='flex';
}

/* ===== Desenho ===== */
function draw(){
  fitCanvasAndRadius();
  ctx.clearRect(0,0,canvas.width,canvas.height);
  ctx.fillStyle = css('--bg'); ctx.fillRect(0,0,canvas.width,canvas.height);

  ctx.lineWidth=2; ctx.strokeStyle=css('--line');
  for(let i=0;i<N;i++){
    const [q,r]=COORDS[i];
    const cx=HEX_R*(Math.sqrt(3)*(q+r/2))+originX;
    const cy=HEX_R*(1.5*r)+originY;
    const poly=hexPolygon(cx,cy);
    ctx.beginPath(); ctx.moveTo(poly[0][0],poly[0][1]); for(let k=1;k<6;k++) ctx.lineTo(poly[k][0],poly[k][1]); ctx.closePath();
    ctx.fillStyle=css('--board'); ctx.fill(); ctx.stroke();
    const v=board[i];
    if(v!==VAZIO){ ctx.beginPath(); ctx.arc(cx,cy,HEX_R*0.6,0,Math.PI*2); ctx.fillStyle=PIECE_RGB[v]; ctx.fill(); ctx.lineWidth=2; ctx.strokeStyle='#000'; ctx.stroke(); }
  }
}

/* Boot */
document.getElementById('startModal').style.display='flex';
draw();
})();
</script>
</body>
</html>
